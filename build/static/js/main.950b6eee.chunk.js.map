{"version":3,"sources":["Effects.jsx","index.jsx"],"names":["Effects","composer","useRef","useThree","scene","gl","size","camera","aspect","useMemo","THREE","width","height","useEffect","current","setSize","useFrame","render","ref","args","attachArray","kernelRadius","maxDistance","FXAAShader","material-uniforms-resolution-value","renderToScreen","extend","EffectComposer","ShaderPass","RenderPass","SSAOPass","UnrealBloomPass","tempObject","tempColor","colors","Array","fill","map","niceColors","Math","floor","random","Boxes","useState","hovered","set","colorArray","Float32Array","from","flatMap","_","i","toArray","previous","state","time","clock","getElapsedTime","rotation","x","sin","y","z","id","position","geometry","attributes","color","needsUpdate","scale","updateMatrix","setMatrixAt","matrix","instanceMatrix","onPointerMove","e","instanceId","onPointerOut","undefined","attach","attachObject","vertexColors","ReactDOM","antialias","alpha","near","far","onCreated","setClearColor","intensity","document","getElementById"],"mappings":"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","file":"static/js/main.950b6eee.chunk.js","sourcesContent":["import * as THREE from 'three'\nimport React, { useRef, useEffect, useMemo } from 'react'\nimport { extend, useThree, useFrame } from 'react-three-fiber'\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer'\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass'\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass'\nimport { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass'\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass'\nimport { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader'\n\nextend({ EffectComposer, ShaderPass, RenderPass, SSAOPass, UnrealBloomPass })\n\nexport default function Effects() {\n  const composer = useRef()\n  const { scene, gl, size, camera } = useThree()\n  const aspect = useMemo(() => new THREE.Vector2(size.width, size.height), [size])\n  useEffect(() => void composer.current.setSize(size.width, size.height), [size])\n  useFrame(() => composer.current.render(), 2)\n  return (\n    <effectComposer ref={composer} args={[gl]}>\n      <renderPass attachArray=\"passes\" scene={scene} camera={camera} />\n      <sSAOPass attachArray=\"passes\" args={[scene, camera]} kernelRadius={0.6} maxDistance={0.03} />\n      <unrealBloomPass attachArray=\"passes\" args={[aspect, 2, 1, 0.991]} />\n      <shaderPass\n        attachArray=\"passes\"\n        args={[FXAAShader]}\n        material-uniforms-resolution-value={[1 / size.width, 1 / size.height]}\n        renderToScreen\n      />\n    </effectComposer>\n  )\n}\n","import * as THREE from 'three'\nimport ReactDOM from 'react-dom'\nimport React, { useRef, useMemo, useState, useEffect } from 'react'\nimport { Canvas, useFrame } from 'react-three-fiber'\nimport niceColors from 'nice-color-palettes'\nimport Effects from './Effects'\nimport './styles.css'\n\nconst tempObject = new THREE.Object3D()\nconst tempColor = new THREE.Color()\nconst colors = new Array(1000).fill().map(() => niceColors[17][Math.floor(Math.random() * 5)])\n\nfunction Boxes() {\n  const [hovered, set] = useState()\n  const colorArray = useMemo(() => Float32Array.from(new Array(1000).fill().flatMap((_, i) => tempColor.set(colors[i]).toArray())), [])\n\n  const ref = useRef()\n  const previous = useRef()\n  useEffect(() => void (previous.current = hovered), [hovered])\n\n  useFrame(state => {\n    const time = state.clock.getElapsedTime()\n    ref.current.rotation.x = Math.sin(time / 4)\n    ref.current.rotation.y = Math.sin(time / 2)\n    let i = 0\n    for (let x = 0; x < 10; x++)\n      for (let y = 0; y < 10; y++)\n        for (let z = 0; z < 10; z++) {\n          const id = i++\n          tempObject.position.set(5 - x, 5 - y, 5 - z)\n          tempObject.rotation.y = Math.sin(x / 4 + time) + Math.sin(y / 4 + time) + Math.sin(z / 4 + time)\n          tempObject.rotation.z = tempObject.rotation.y * 2\n          if (hovered !== previous.current) {\n            tempColor.set(id === hovered ? 'white' : colors[id]).toArray(colorArray, id * 3)\n            ref.current.geometry.attributes.color.needsUpdate = true\n          }\n          const scale = id === hovered ? 2 : 1\n          tempObject.scale.set(scale, scale, scale)\n          tempObject.updateMatrix()\n          ref.current.setMatrixAt(id, tempObject.matrix)\n        }\n    ref.current.instanceMatrix.needsUpdate = true\n  })\n\n  return (\n    <instancedMesh ref={ref} args={[null, null, 1000]} onPointerMove={e => set(e.instanceId)} onPointerOut={e => set(undefined)}>\n      <boxBufferGeometry attach=\"geometry\" args={[0.7, 0.7, 0.7]}>\n        <instancedBufferAttribute attachObject={['attributes', 'color']} args={[colorArray, 3]} />\n      </boxBufferGeometry>\n      <meshPhongMaterial attach=\"material\" vertexColors={THREE.VertexColors} />\n    </instancedMesh>\n  )\n}\n\nReactDOM.render(\n  <Canvas\n    gl={{ antialias: false, alpha: false }}\n    camera={{ position: [0, 0, 15], near: 5, far: 20 }}\n    onCreated={({ gl }) => gl.setClearColor('lightpink')}>\n    <ambientLight />\n    <pointLight position={[150, 150, 150]} intensity={0.55} />\n    <Boxes />\n    <Effects />\n  </Canvas>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}